# Encoding Design

Before we start with this part of the project, it is essential that you receive some background information.
Without it, you would have no idea of what you're doing or should be doing.

## Huffman Coding

### Abstract View

Let's start with a high level view of what Huffman coding is about.

.High Level View
image::huffman1.svg[Static,align="center"]

### Bits and Bytes

Let's add some detail.
While technically, Huffman can operate on all kinds of input data, we will assume it receives a sequence of _bytes_.
Each individual byte will be counted, a Huffman tree will be built that is then used to assign a Huffman code to each byte, and finally Huffman will go over the input data again and, for each byte, output the corresponding Huffman code.

Huffman codes operate on the level of bits: they can be 3 bits long, 5 bits, 99 bits.
Any number of bits is possible.
Our goal, however, is to write this compressed data to file, and files want bytes, not individual bits.
This means we will have to take care of bundling bits into bytes ourselves.
Conversely, when decompressing, we will need to do the opposite: the Huffman decoder expects bits as input, while the original data is expressed in bytes.

For this reason, we add a bit grouper and a byte splitter to the diagram.

.Splitting and Grouping
image::huffman2.svg[Static,align="center"]

Let's replace the arrow labels by the number of possible values transmitted: bits have 2 possible values, byte have 256.

.With Domain Sizes
image::huffman3.svg[Static,align="center"]

[[eof]]
### EOF

There's a snag unfortunately.
Let's Huffman encode the string

[.center,%header,cols="^",width=25%]
|===
| `AAAABCB`
|===

The frequency table is

[.center,%header,cols="^,^",width=50%]
|===
| Datum | Frequency
| `A` | 4
| `B` | 2
| `C` | 1
|===

We build a Huffman tree:

image::huffman-tree2.svg[Static,align="center"]

The Huffman codes are then

[.center,%header,cols="^,^",width=50%]
|===
| Datum | Code
| `A` | 0
| `B` | 10
| `C` | 11
|===

We use these codes to encode the input stream:

[.center,%header,cols="^",width=25%]
|===
| `0000101110`
|===

These are 10 bits.
Grouping them into bytes gives us

[.center,%header,cols="^",width=25%]
|===
| `00001011 10000000`
|===

where we needed to pad the second byte with ``0``s to reach a required 8 bit length.
Now let's decompress it:

[.center,%header,cols="^",width=25%]
|===
| `AAAABCBAAAAAA`
|===

Oh no!
The padding needed get to 2 bytes is being interpreted as extra data.
We need a way to tell the algorithm where the bit stream ends.

As always, there are multiple ways to go about it.
What we will do, is add an extra data element at the end of the original data stream, named EOF (End Of File).
Let's use {eof} as a symbol for EOF.
Our input stream would then become

[.center,%header,cols="^",width=25%]
|===
| `AAAABCB{eof}`
|===

What's peculiar about this symbol is that it can't be any one of the 256 possible byte values in the input stream.
Say we'd use `!`` to indicate EOF, then we couldn't compress any data containing `!` as it would be mistaken for EOF.
This means we need to add a 257th value to the list, a wholly new value.
Remark that {eof} does not appear in the http://www.asciitable.com/[ASCII table], further confirming it falls outside the range of bytes.

[NOTE]
====
When dealing with input data elements, it's better to use the term _datum_ instead of _byte_.
Byte is linked to 8 bits and 256 possible values.
We need a more general concept, one that also allows for 257 possible values (or more, or less.)

This is also why out `InputStream` and `OutputStream` classes don't work with `uint8_t` but with `uint64_t`: it gives us breathing room to add new symbols.
====

If we perform our compression on our updated input stream, we get as frequencies

[.center,%header,cols="^,^",width=50%]
|===
| Datum | Frequency
| `A` | 4
| `B` | 2
| `C` | 1
| `{eof}` | 1
|===

This leads to

image::huffman-tree3.svg[Static,align="center"]

[.center,%header,cols="^,^",width=50%]
|===
| Datum | Code
| `A` | 0
| `B` | 10
| `C` | 110
| `{eof}` | 111
|===

and finally

[.center,%header,cols="^",width=25%]
|===
| `00001011 01011100`
|===

While decompressing, we will know the file ended as soon as we encounter {eof}.

We will place the responsibility of dealing with {eof} in a separate component:

.Dealing with EOF
[[figeof]]
image::huffman4.svg[Static,align="center"]

## Encoders &amp; Decoders

### Symmetry

As you can see in the <<figeof,diagram above>>, the compression/decompression process is split in multiple steps.
These steps are also each other's inverse operations:

* EOF adder and EOF remover counteract each other.
* Huffman encoder and Huffman decoder counteract each other.
* Bit grouper and byte splitter counteract each other.

### Domain Size Constraints

Note also that the components interact with the domain sizes:

* EOF adder takes in data with domain size `N` and will add an extra symbol, so it outputs data with domain size `N + 1`.
* EOF remover does the exact opposite: data with domain size `N` is transformed into data with domain size `N - 1`.
* The Huffman encoder can take any kind of data, but always reduces it to data with domain size 2 (i.e. bits).
* The Huffman decoder, as expected, does the opposite: it expects input with domain size 2 and generates data of any domain size.
* The bit grouper expects input with domain size 2 and can produce datums of any size, e.g., it can bunch bits together in groups of 2, 8, 16, etc.
  In our use case, we need 8, but there's no real limitation.
* The byte splitter takes datums of any size and produces bits (domain size 2).

In other words, we cannot link any two components but have to keep their limitations in mind.

[[encoding]]
### The Encoding Type

Our goal is to be able to easily construct such "inverse pipelines" and have the compiler check that the different components are indeed compatible with each other.
To achieve this, we will introduce a class `Encoding`.
It will have the following purpose:

* It will pair up the encoder and decoder.
* Encodings can be combined into a pipeline, as we have done above.
* Its type will express which domain sizes it operates on.
  This will allow the compiler to check we're respecting the different encoders' demands.

For example, in the pipeline shown above, we have three encodings:

* The `eof_encoding` (the encoder adds {eof}, the decoder removes {eof}.)
* The `huffman_encoding` (the encoder compresses, the decoder decompresses.)
* The `bit_grouper` encoding (the encoder groups bits, the decoder splits into bits.)

Combining would be done using the `|` operator.
The following code would produce both the forward (compressing) and backward (decompressing) pipeline discussed earlier:

[source,language='cpp']
----
auto pipeline = eof_encoding() | huffman_encoding() | bit_grouper();
----

[[checks]]
### Compiler Checks

[NOTE]
====
This paragraph is a bit advanced, but once the time has come for you to implement it, you will receive the necessary guidance.
====

We only want to allow to combine encodings that are compatible with each other.
If one encoding produces data with domain size `N`, the next in line should accept such data.
Not only do we want to check this, we want to do so at _compile-time_.

To make this possible, the compiler needs to know about each encoder's expectations.
We need to encode the domain sizes in the type using <<templates#nontype,template parameters>>: we will be using `Encoding<IN, OUT>`, where `IN` and `OUT` denote the domain sizes.

* `eof_encoding` will be an `Encoding<N, N+1>` with `N` freely chosen.
  This means that the _encoder_ will take data with domain size `N` and produce data with domain size `N+1`, while the _decoder_ will perform the opposite operation.
* `huffman_encoding` will be an `Encoding<N, 2>`: it reduces everything to bits.
* `bit_grouper` will be an `Encoding<2, 1 << K>` where `K` is the group size.
  `1 << K` is actually equal to 2^`K`^, meaning if we take `K` bits together, we get domain size 2^`K`^.
  Don't worry about this part if it isn't entirely clear.

The combiner operator `|` will then have to check that the domain sizes match up:

[.center,cols="^",width=75%]
|===
| `Encoding<N1, N2> \| Encoding<N2, N3>` &rarr; `Encoding<N1, N3>`
|===

* Notice how the output domain size of the left operand (`N2`) is equal to the input domain size of the right operand.
* Also notice how combining two encodings yields a new encoding.
  This allows us to chain as many encodings as we want.
