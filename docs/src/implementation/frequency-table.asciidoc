# FrequencyTable

## Context

The first thing (nonadaptive) Huffman encoding needs to do is count the frequencies of each byte in its input stream.
We will create a class `FrequencyTable` to assist us in this task.

A bit of terminology (apologies if this is confusing - I can change it if necessary):

* The `FrequencyTable` clearly is a map-like data structure: it associates certain values with other values.
  In our case, it associates values with frequencies.
* When using maps, we generally say _keys_ are associated _values_.
  Here, I used different terms: the `FrequencyTable` associates _values_ with _frequencies_.

## Python Implementation

See `freqtable.py`.

## Goal

* `FrequencyTable` must be able to count _any_ kind of values. E.g., we want to be able to count chars with a `FrequencyTable<char>`, or strings with `FrequencyTable<std::string>`, etc.
* Required functionality:
** `freqtable.increment(x)` must increment the frequency of `x`.
** `freqtable[x]` must return the frequency of `x`.
** `freqtable.values()` must return a list of all values which have ever been counted.

### Example Usage

[source,language="cpp"]
----
// Create new frequency table to count chars
FrequencyTable<char> freqtable;

// Count 'a' one time
freqtable.increment('a');

// Count 'b' twice
freqtable.increment('b');
freqtable.increment('b');

// Query frequencies
freqtable['a']  // -> 1
freqtable['b']  // -> 2
freqtable['c']  // -> 0

// Ask for list of values
std::vector<char> letters = freqtable.values(); // -> { 'a', 'b' }
----

## Class Implementation

### Skeleton

[TASK]
====
* In the Solution Explorer, create a folder `data`.
* In this folder, add a new file `frequency-table.h`.
* Add <<include-guards#,include guards>>.
* Add a <<namespaces#,namespace>> named `data`.
  All further `FrequencyTable` related code will reside within this namespace.
====

We want our `FrequencyTable` to be flexible and not hardcode it to use a specific type.
Therefore, we choose to make it a template class.

[TASK]
====
Create an empty <<templates#class,template class>> named `FrequencyTable` inside the `data` namespace.
====

### Fields

A `FrequencyMap` associates values of type `T` with frequencies of integral type.
There are many integral types, so which one would you use, taking into account that

* frequencies cannot go negative;
* we want the largest type available that's still directly supported by the cpu.

Look for the right https://en.cppreference.com/w/cpp/container/map[data structure] to store these value-frequency associations in.

[TASK]
====
Add a private field that will store the frequency data.

No funny business with pointers or references is needed here.
Keep it simple.
====

### Constructor

No constructor should be needed.
The field will automatically construct itself.

.Example usage
[%collapsible]
====
[source,language='cpp']
----
FrequencyTable<char> freqtable;
----
====

### Destructor

No destructor should be needed.

### Method `increment`

`freqtable.increment(x)` method should increase the frequency of `x`.

[TASK]
====
Implement this method.

* It requires one parameter `x`.
  What should its exact <<parameter-types#,type>> be?
** `increment` needs only read access to `x`.
** `increment` needs to store ``x``'s value somewhere in its internal data structure, but it needs to be a _copy_ of `x`.
   This is due to the fact that it will be used as a key in a map-like data structure, and we can't allow keys to be modified lest the map fail to work.
   Making a copy is the safest way to make sure no one gets to modify the key.
** You know nothing about `T`: it might be small or large.
   Better play it safe.
** No ownership transfer is necessary (neither full or partial).
* Think of <<const-correctness#,`const`-correctness>>: is this a `const` method?
====

.Example usage
[%collapsible]
====
[source,language='cpp']
----
FrequencyTable<char> freqtable;
freqtable.increment('a'); // a has now frequency 1
----
====

### Indexing

We need a way to ask a `FrequencyTable` what the frequency of some value `x` is.
Instead of using a regular method, we will be using the syntax `freqtable[x]`.

If `x` has never been `increment`ed before, `freqtable[x]` should return `0`.

[TASK]
====
Overload the `[]` operator.

* It takes the value as parameter. What should its exact <<parameter-types#,type>> be?
  Note that this function will use it in more or less the same way as `increment`:
** Size of `T` is unknown, so do not assume it is small.
** No write access needed.
** No ownership transfer.
* Return type: keep it simple.
* Think of <<const-correctness#,`const`-correctness>>.
* You might have to look up online how to find out if some `x` is https://www.cplusplus.com/reference/map/map/find/[part of a map or not].
====

[NOTE]
====
If you look online, they will often show an implementation that returns a reference.
This gives write access to the caller:

[source,language='cpp']
----
freqtable[x] = 5;
----

We do not want such functionality.
`freqtable[x]` should simply give us the frequency, nothing more.
====

.Example usage
[%collapsible]
====
[source,language='cpp']
----
FrequencyTable<char> freqtable;
freqtable['a']; // returns 0
freqtable.increment('a');
freqtable['a']; // returns 1
----
====

### Method `values`

This method should return a list of _values_ (i.e., not the frequencies.)
Return them using a `std::vector`.

[TASK]
====
Implement this method.

* No parameters needed.
* Think of <<const-correctness#,`const`-correctness>>.
* Return type: keep it simple and simply return the vector by value. No reference/pointer shenanigans necessary.
====

.Example usage
[%collapsible]
====
[source,language='cpp']
----
FrequencyTable<char> freqtable;
freqtable.values() // returns empty list { }
freqtable.increment('a');
freqtable.values() // returns list { 'a' }
----
====

## Helper Function

We want a helper function `count_frequencies` that given a vector of values, counts them and returns the frequencies as a `FrequencyTable`.
This function should reside _outside_ the class (but still inside the `data` namespace).

[TASK]
====
* This function is a <<templates#functions,template>>.
* It takes a vector of values as a parameter.
** This vector has the potential to be very large.
** The function needs only read access.
** The function does not store the vector internally.
* Return type: return the `FrequencyTable` by value.
====