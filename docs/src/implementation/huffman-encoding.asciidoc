# Huffman Encoding

This part will be more algorithmic in nature.
We remind you that you have a working Python implementation.
Use it to understand what you're supposed to be doing and to compare intermediate results.

You are free to organize your code as you wish, but we suggest you spread your code over multiple files in a `encoding/huffman` folder.
This allows you to easily exclude certain parts of your code.
If you have multiple compile errors, you can then focus on one at a time by excluding unimportant files.

[IMPORTANT]
====
Keep an eye on the whole.
Know exactly what you're trying to achieve at every step.
====

[IMPORTANT]
====
Don't be afraid to split code into multiple functions and test each function separately.
If you ask for help and I see big chunks of code, I'll simply tell you to split it up and write tests for each.
====

## Groundworks

We will implement Huffman coding as another kind of encoding.

[TASK]
====
In a `.cpp` file (e.g. `encoding/huffman/huffman-encoding.cpp`), inside an anonymous namespace, start a class definition `HuffmanEncodingImplementation`.
We'll add fields as we need them.

Add empty `encode` and `decode` overriding methods.
====

## Huffman Encoding

Encoding consists of multiple steps:

* Count the frequency of each datum in the input stream.
* Build a Huffman tree.
* Determine the Huffman code for every datum.
* Write the Huffman tree to the output stream.
* For each datum in the input stream, write its corresponding Huffman code to the output stream.

### Copying the InputData

``InputStream``s only allows you to query its data once.
Yet, we need to go through it twice: once for counting, once for encoding.
The only way around this is to store all data in memory.

[TASK]
====
Write a function `copy_to_vector` that takes an `InputStream` and copies all data into a `std::vector`.

You can implement this function in several ways:

* As a member of `HuffmanEncodingImplementation`.
  This prevents you from testing it though, since the class is hidden inside a `.cpp`.
* As a standalone function (i.e., not part of a class).
  You can then make it available to the tests by adding a declaration in the corresponding `.h` file.
  The disadvantage of this approach is that you need all code in the same file to compile before you can run the tests.
* In its own files, e.g., `copy-to-vector.cpp` and `copy-to-vector.h`.
  Testing-wise, this affords you the most flexibility.
  It's not great for abstraction though since you expose part of the inner workings of your class.
====

[TASK]
====
Add this first step (copying the data) to `HuffmanEncodingImplementation::encode`.
====

### Counting Frequencies

Counting frequencies should require only very little work: you have already made a `FrequencyTable` and a helper function `count_frequencies`.

[TASK]
====
Add code to `HuffmanEncodingImplementation::encode`: call <<frequency-table#countfreqs,`count_frequencies`>> to count the elements in the input stream.
====

### Building the Tree

The algorithm goes as follows:

* Create binary tree leaves carrying a datum and its corresponding frequency.
* Put these in a list.
* Loop until the list contains only one element anymore:
** Take the two elements with the lowest weight.
** Create a branch with these two elements as children.
** Put this branch in the list.
* At this point, the list contains one item, which is the root of the Huffman tree.

[TASK]
====
Implement a function `encoding::huffman::build_tree` that takes a `FrequencyTable<Datum>` and returns a Huffman tree.

* Think of the <<parameter-types#,parameter type>> for the frequency table.
** It is a large object.
** It needs no modifications.
** No ownership transfer is necessary.
* `build_tree` creates a tree.
  This tree will have to be created on the heap, because otherwise there's no way to return it: if it were created on the stack, it would be deallocated again as soon as `build_tree` returns.
  Once `build_tree` is done building the tree, it should not just return the tree, but also complete ownership.
  Deallocating the tree thereby becomes the caller's responsibility.

A few tips:

* You need to represent binary trees.
** Remember you have <<binary-tree#,already written code>> for this exact purpose.
** `Node<T>` represents a tree whose leaves carry a `T`.
   In our case, we want each leaf to carry both a `Datum` and a frequency.
   You can make use of https://www.cplusplus.com/reference/utility/pair/pair/[`std::pair`] for this.
* Given a tree node, whether it be a branch or a leaf, you need to be able to determine its weight.
  For leaves, this is simple: they carry it themselves.
  For branches, you need to take the sum of the weights of their children.
  Write a helper function `weight` that takes a `Node`, looks if its a leaf or a branch, and based on that determines the weight.
* Given a list of nodes, you need to find the two that have the lowest weight.
  There are multiple ways to achieve this.
** You can sort the list making use of https://en.cppreference.com/w/cpp/algorithm/sort[`std::sort`].
** You can find use https://en.cppreference.com/w/cpp/algorithm/min_element[`std::min_element`] to find the "smallest" element in a list.
** Instead of keeping a randomly ordered list and having to find the smallest element, you could simply insert new elements in a smart way such that the list remains sorted at all times.
* https://en.cppreference.com/w/cpp/container/vector[`std::vector`] does offer methods to add and remove elements at the end (`push_back` and `pop_back`), but there are no such methods to add and remove at the front (i.e., there are no `push_front` or `pop_front` methods), this due to this operation being slow.
  If you choose to have the elements sorted in the list, it might be advantageous to have the smallest elements at the end of the list.
====

[TASK]
====
Add code to `HuffmanEncodingImplementation::encode` to build the tree.
====

### Building Codes

[TASK]
====
Write a function `build_codes`.

* `build_codes` takes a Huffman tree as parameter.
** The tree does not need to be modified.
** The tree is a large object.
** `build_codes` is not interested in ownership.
* `build_codes` must return codes for each `Datum`.
  You need a data structure to store these codes in.
** A https://en.cppreference.com/w/cpp/container/map[`std::map`] could work.
** Since you know the ``Datum``s range from `0` to some maximum value, you could also use a https://en.cppreference.com/w/cpp/container/vector[std::vector], which will probably be much more efficient.
   You can store the code for `Datum` `i` on index `i`.
* Codes are really a sequence of bits.
  You can simply use `std::vector<Datum>` for this purpose.
====

[TASK]
====
Add code to `HuffmanEncodingImplementation::encode` to build the codes using the previously written function.
====

### Writing the Huffman Tree

You've done the work in a previous step of this guide, so it's just a matter of calling the right function.
However, it requires to be aware of the datum size.
We need to get this information from somewhere.
Let's apply the standard solution: ask for it in ``HuffmanEncodingImplementation``'s constructor and store it in a field.

[TASK]
====
* Add a field storing the domain size.
* Add a parameter `domain_size` to the `HuffmanEncodingImplementation` constructor and have it store it in the field.
* Add code to `HuffmanEncodingImplementation::encode` to write the Huffman tree to the `OutputStream`.
  Translate the domain size to actual bits needed using a previously written function.
====

### Encoding

This step should be trivial: go through all input data and look up the corresponding codes.
Send this codes to the output stream, bit by bit.

[TASK]
====
Implement the encoding step.
====

## Huffman Decoding

We now turn our attention to the decoding part.
This involves the following steps:

* Reconstruct the Huffman tree.
* Read the bits and decode them.

[NOTE]
====
Decoding only requires a single pass, so contrary to `encode`, we do not need to copy all of our input data first.
====

### Reading Tree

You've already implemented this functionality earlier.

[TASK]
====
Add code to `HuffmanEncodingImplementation::decode` to read in the Huffman tree from the `InputStream`.
====

### Decoding

### Decoding a Single Datum

Let's focus on decoding a single datum.
Next, we can simply call that functionality in a loop.

Before beginning, make sure you understand how the decoding process works.
We suggest the following approach for the implementation:

* A raw pointer points to the _current node_.
  Initially, this would be the root of the tree.
  We assume this root is actually a `Branch`, not a `Leaf`.
  If this is not the case, something went quite wrong.
* Loop
** Read a bit.
** If `0`, move the pointer to the left child.
** If `1`, move the pointer to the right child.
** Check the dynamic type of the current node.
*** If it's a `Leaf`, we're finished with the current Datum and can forcibly leave the loop by simply returning the ``Leaf``'s datum.

[IMPORTANT]
====
Remember that while encoding, we needed to add extra bits so as to fill up the last byte so as to be able to write it to file.
These extraneous bits have _not_ been removed at this point: your Huffman decoder will encounter these extra bits.

So, what to do?
Fortunately, the only problem you'll have to deal with is that you might encounter the end of the `InputStream` before reaching a `Leaf`.
To remedy this, you need to check for the end of stream and, if you reach it, simply return `0` as datum.

This datum is of course wrong, but that's okay: the EOF encoder will take care to remove it.
====

[TASK]
====
Implement a function `decode_single_datum`.

* It receives two parameters:
** The `InputStream`.
** The Huffman tree.
* It returns a `Datum`.
====

### Decoding all Data

This one is quite easy to implement: keep decoding a single datum until the end of the stream is reached.
All `Datum` values returned by `decode_single_datum` need to be written to an `OutputStream`.

[TASK]
====
Implement a function `decode_bits`.

* It takes three parameters:
** An `InputStream`.
** A Huffman tree.
** An `OutputStream`.
====

[TASK]
====
Call this function from `HuffmanEncodingImplementation::decode`.
====

## Testing

Your Huffman implementation should be complete now.
Test it thoroughly.
